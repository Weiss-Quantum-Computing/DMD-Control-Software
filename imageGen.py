import numpy as np
import pandas as pd
import math
import random
import matplotlib.pyplot as plt
from pypylon import pylon
from pypylon import genicam 
import itertools
from timeit import default_timer as timer

dmdX = 1280
dmdY = 800

def setup():
    #allows user to specify m x n beams
    global cols, rows, calibrated, imgSeq, currentArr
    #1D array used as image input into the DMD, consists of flattened 2D images
    imgSeq = []
    #currentArr is the template that will be constantly manipulated and reset
    #when it takes form of a desired image, it is copied into imgSeq using imgSeq.extend(np)
    currentArr = np.full((dmdY,dmdX), False)
    cols = 7
    rows = 7
    #loads list of 49 calibrated beams from calibSave.npy, generated by DMDcalib
    calibrated = np.load("calibSave.npy")

#clears the currentArr template
def resetcurrArr():
    global currentArr 
    currentArr = np.zeros((dmdY,dmdX))

#turns on a single beam at row,col
def turnOn(row,col):
    global currentArr
    #selects the correct beam from the calibrated list and adds it to the template while ignoring overlaps, implemented as logical or
    currentArr = np.logical_or(currentArr,calibrated[row*cols+col])

#turns off a single beam at row,col
def turnOff(row,col):
    global currentArr
    #selects the correct beam from the calibrated list and subtracts it from the template while ignoring pixels that are already off, implemented as material nonimplication
    currentArr = np.logical_and(currentArr,~calibrated[row*cols+col])

#directly adds a fully on image to the sequence
def fullOn():
    global imgSeq
    imgSeq.extend(np.full(dmdY*dmdX, 255))

#directly adds a fully off image to the sequence
def fullOff():
    global imgSeq
    imgSeq.extend(np.zeros(dmdY*dmdX))

#directly adds an image with all beams in the active area on
def allBeamsOn():
    global imgSeq, currentArr
    for i in range(rows):
        for j in range(cols):
            turnOn(i,j)
    imgSeq.extend(np.ravel(currentArr))
    vis = plt.imshow(currentArr)
    vis.set_cmap('binary')
    plt.show()
    resetcurrArr()

#generates seqeunce of vertical bars going left to right
def horiscan():
    global imgSeq, currentArr
    while True:
        width = int(input("Enter width of scanning bar (in pixels): ") or str(10))
        if dmdX%width!=0:
            print("Please enter a width that evenly divides the DMD dimension.")
            continue
        else:
            break
    #if you want the first 40 frames, you would set start to 0 and end to 40, and the printed image number will go from 0 to 39, basically enter start and end following zero-indexing [)
    start = int(input("Enter starting frame: ") or str(0))
    end = int(input("Enter end frame: ") or str(int(dmdX/width)))
    for i in np.arange(start, end):
        currentArr[:,i*width:(i+1)*width] = np.full((dmdY,width), 255)
        imgSeq.extend(np.ravel(currentArr))
        resetcurrArr()

#generates sequence of horizontal bars going top to bottom
def vertscan():
    global imgSeq, currentArr
    while True:
        width = int(input("Enter width of scanning bar (in pixels): ") or str(10))
        if dmdY%width!=0:
            print("Please enter a width that evenly divides the DMD dimension.")
            continue
        else:
            break
    start = int(input("Enter starting frame: ") or str(0))
    end = int(input("Enter end frame: ") or str(int(dmdY/width)))
    for i in np.arange(start, end):
        currentArr[i*width:(i+1)*width,:] = np.full((width,dmdX), 255)
        imgSeq.extend(np.ravel(currentArr))
        resetcurrArr()

#generates rows*cols images, one beam on per image
def onebeam():
    global imgSeq, currentArr
    for i in range(rows):
        for j in range(cols):
            turnOn(i,j)
            imgSeq.extend(np.ravel(currentArr))
            turnOff(i,j)

def pairrandom():
    global imgSeq, currentArr
    for i in range(rows):
        for j in range(cols):
            if(random.random()>0.5):
                turnOn(i,j)
    imgSeq.extend(np.ravel(currentArr))
    resetcurrArr()
    for i in range(rows):
        for j in range(cols):
            if(random.random()>0.5):
                turnOn(i,j)
    imgSeq.extend(np.ravel(currentArr))
    resetcurrArr()

#enter beams in lattice position form, i.e row,col and if no input is given then we move on to the next image
def custombeam():
    global imgSeq, currentArr
    nbImg = int(input("Enter number of images in sequence: "))
    for i in range(nbImg):
        while True:
            beam = input("Enter position of new on beam in image #{} as row,col: ".format(i+1))
            #if finished entering beams for the current image, just enter nothing
            if not beam:
                break
            else:
                beampos=[int(x) for x in beam.split(",")]
                row=beampos[0]
                col=beampos[1]
                turnOn(row,col)
        imgSeq.extend(np.ravel(currentArr))
        resetcurrArr()

def randoneperrow():
    global imgSeq, currentArr
    for i in np.arange(rows):
        j = random.choice(range(cols))
        turnOn(i,j)
    imgSeq.extend(np.ravel(currentArr))
    resetcurrArr()

#generates all images with at most one beam on per row
def oneperrow():
    global imgSeq, currentArr
    #e.g. for 7 by 7 array, loops through every possible pattern of at most one beam in each of the seven rows, eight options per row, rows are independent of each other
    for x in itertools.product(range(cols+1),repeat=rows):
        #each entry in x denotes a column, and the number of entries in x is equal to the number of rows
        for row,col in enumerate(x):
            print(row,col)
            #e.g. if there are 7 columns indexed 0 to 6, defines column 7 as no beams on in that row
            if col==cols:
                continue
            turnOn(row,col)
        imgSeq.extend(np.ravel(currentArr))
        resetcurrArr()

#creates the checkerboard image with top left beam on
def checkerone():
    global imgSeq, currentArr
    for i in np.arange(rows):
        if i%2==0:
            for j in np.arange(0,cols,2):
                turnOn(i,j)
        else:
            for j in np.arange(1,cols,2):
                turnOn(i,j)
    imgSeq.extend(np.ravel(currentArr))
    vis = plt.imshow(currentArr)
    vis.set_cmap('binary')
    plt.show()
    resetcurrArr()

#creates the checkerboard image with top left beam off
def checkertwo():
    global imgSeq, currentArr
    for i in np.arange(rows):
        if i%2==0:
            for j in np.arange(1,cols,2):
                turnOn(i,j)
        else:
            for j in np.arange(0,cols,2):
                turnOn(i,j)
    imgSeq.extend(np.ravel(currentArr))
    vis = plt.imshow(currentArr)
    vis.set_cmap('binary')
    plt.show()
    resetcurrArr()

#generates all images with exactly two beams on
def twobeams():
    global imgSeq, currentArr
    #loops through all 49choose2 pairs of beams, then uses // and % to get the row and column number
    for x,y in itertools.combinations(range(rows*cols),2):
        b1 = (x//cols,x%cols)
        b2 = (y//cols,y%cols)
        turnOn(b1[0],b1[1])
        turnOn(b2[0],b2[1])
        imgSeq.extend(np.ravel(currentArr))
        turnOff(b1[0],b1[1])
        turnOff(b2[0],b2[1])
        
#######CODE HERE#######
setup()
allBeamsOn()

np.save("img.npy", np.asarray(imgSeq)*255)
#######CODE HERE#######